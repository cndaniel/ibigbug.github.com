<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>
Javascript中的debounce模式 -
 8D is Here</title>
        <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1">
        <link media="all" rel="stylesheet" href="/static/default/css/reset.css" type="text/css" />
        <link media="all" rel="stylesheet" href="/static/default/css/typo.css" type="text/css" />
        <link media="all" rel="stylesheet" href="/static/default/css/style.css" type="text/css" />
        <link rel="alternate" href="http://blog.xiaoba.me/feed.xml" type="application/rss+xml" title="RSS" />
    </head>
    <body>
        <header id="header">
            <h1 class="brand"><a href="/">8D is Here</a></h1>
            <nav id="nav">
                <ul class="fn-clear">
                    <li class="fn-left">
                    <a class="nav-home" href="/">Home</a>
                    </li>
                    
                    <li class="fn-left">
                    <a class="nav-life" href="/life">Life</a>
                    </li>
                    
                    <li class="fn-left">
                    <a class="nav-work" href="/work">Work</a>
                    </li>
                    
                    <li class="fn-left">
                    <a href="/feed.xml">Feed</a>
                    </li>
                </ul>
            </nav>
        </header>
        <div class="wrap typo">
            
<div class="entry">
    <h1 class="entry-title"><a href="/debounce-in-javascript.html">Javascript中的Debounce模式</a></h1>
    <small class="entry-meta">
        Published on
        <time datetime="2013-07-26">2013-07-26</time>
        
        in <a href="/work">Work</a>
        
    </small>
    <div class="entry-content">
        <blockquote>
<p>轻一点，求求你&gt;&lt;</p>
</blockquote>
<h2>1.What——什么是debounce模式？</h2>
<p>如果你写过单片机开发的键盘扫描，那么你一定知道要进行「去抖动」。没错，在JS处理页面交互事件时，往往也需要进行一些去抖处理，这就是debounce。当然这里只是借用了名字，其实与键盘扫描的去抖，还是有一点差别的。下面有个效果演示，如果你心急，直接拉下去看效果。</p>
<h2>2.Why——为什么要debounce？</h2>
<p>正如引言中所述，对于「猛击」的现象，我们需要使用<code>debounce</code>来让点击轻一点~比如用户在进行订单提交的时候，需要单击「提交」按钮，往往会有意或者无意的出现「双击」甚至「多击」的现象，如果JS对每次单击都相应一次，发出一个请求到后台，那么一方面，可能会造成逻辑错误，也就是造成「下了很多订单」;另一方面，对于「多击」的没一个请求，都会发送到后台，给web服务器增加了压力。</p>
<h2>3.How——如何debounce？</h2>
<p>underscore框架中有一个方法，叫做「debounce」，就是我们今天要介绍的。</p>
<p>这个方法使用起来很简单：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">lazyLayout</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">debounce</span><span class="p">(</span><span class="nx">calculateLayout</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
<span class="nx">$</span><span class="p">(</span><span class="nb">window</span><span class="p">).</span><span class="nx">resize</span><span class="p">(</span><span class="nx">lazyLayout</span><span class="p">);</span>
</pre></div>

<p>上面的代码来自<a href="http://underscorejs.org/##debounce">underscore</a><br />
这样被<code>debounce</code>处理之后的lazyLayout有什么效果呢？</p>
<p>这是underscore中debounce的原型
<div class="highlight"><pre><span class="nx">_</span><span class="p">.</span><span class="nx">debounce</span><span class="p">(</span><span class="kd">function</span><span class="p">,</span> <span class="nx">wait</span><span class="p">,</span> <span class="p">[</span><span class="nx">immediate</span><span class="p">])</span> 
</pre></div></p>
<p>有三个参数：</p>
<ul>
<li>function —— 需要被处理的函数</li>
<li>wait —— 等待时间，也就是说，在函数第一次触发之后，会有<code>wait</code>这么长的一个等待时间，这段时间里，所有对「被debounce过的函数」的调用，全部被丢弃。通俗一点说，你点击一次按钮之后，不论再快速的点多少次按钮，我都只当一次处理，直到你停下来，wait一段时间过后再点击，那才算第二次生效。</li>
<li>[immediate] —— 这是一个很有趣的参数，默认是undefined也就是false，可以设置为true。当为false时，是当计时器计时结束后，执行函数，实际效果就是：你不停的点击，我不管你，当你停下来了，我再重新开始计时，过了设定的时间后，函数被执行;而设置为true时，就是计时器开始计时，就执行函数，之后无论你再怎么疯狂点击，我也不理你了。</li>
</ul>
<p>怎么样，是不是很简单实用？有了这个处理之后，就再也不怕有人误点击，或者疯狂点击按钮提交表单了。  </p>
<p>下面是一个deboucne的演示，顺带还有个throttle对比，你可以不管：<br />
<a href="http://jsfiddle.net/amyseqmedia/dD99u/37/">Underscore.js throttle vs debounce example - jsFiddle</a></p>
<p>那么这么好的方法，是如何实现呢？其实很简单，就是一个计时器，在计时器结束之前，如果发现新的点击（也就是函数调用）请求，将其丢弃，重置计时器。直到计时器结束后，执行函数(immediate为false);或者第一次点击之后，立即调用函数，同时启动计时器，再计时器结束之前，收到新的函数调用请求，丢弃，重置计时器(immediate为true)。下面是underscore的具体实现,我加了一点注释，方便理解：</p>
<div class="highlight"><pre> <span class="nx">_</span><span class="p">.</span><span class="nx">debounce</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">wait</span><span class="p">,</span> <span class="nx">immediate</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>  <span class="c1">// 用户函数调用返回值</span>
    <span class="kd">var</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>  <span class="c1">// 初始化计时器 因为会被返回的闭包引用，所以会保持，不会被GC。有关Javascript中的GC，可以参考[Javascript中的垃圾回收机制](http://blog.xiaoba.me/garbage-collection-in-javascript.html)</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 返回被处理的函数</span>
      <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>  <span class="c1">// 保存现场</span>
      <span class="kd">var</span> <span class="nx">later</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 传给计时器，以便结束时候可以调用</span>
        <span class="c1">// 计时器结束之后，会进入这里</span>
        <span class="nx">timeout</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>  <span class="c1">// 计时结束，重置计时器，以便处理下一次请求</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">immediate</span><span class="p">)</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>  <span class="c1">// immediate为false的话，在这里执行函数</span>
      <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">callNow</span> <span class="o">=</span> <span class="nx">immediate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">timeout</span><span class="p">;</span>  <span class="c1">// 根据immediate和计时器是否结束来判断是否到了调用函数的时机。 注意这里还没有启动计时器，也就是如果设置了immediate为true，那么callNow就是true</span>
      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timeout</span><span class="p">);</span>  <span class="c1">// 这里！ 上面的都是一些变量的声明和赋值，这里开始到了关键，每一次调用请求，执行到这里都会重置计时器，不论immediate是true还是false</span>
      <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">later</span><span class="p">,</span> <span class="nx">wait</span><span class="p">);</span>  <span class="c1">// 然后再这里重新开始计时</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">callNow</span><span class="p">)</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>  <span class="c1">// 注意这里的callNow，是上面赋值的。如果有设置了immediate，那么立即执行函数;如果immediate为false，那么就等上面的计时器结束，执行later</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>  <span class="c1">// 返回结果</span>
    <span class="p">};</span>
  <span class="p">};</span>
</pre></div>

<h2>4.Where —— 哪里用到debounce？</h2>
<p>如上所述，一些类似表单提交，比如下订单，评论，等等有点击事件的地方，都可以用到～</p>
<p><em>以上大部分是个人理解，如有错误，请不吝指出^_^</em></p>
    </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'heheblog';
        var disqus_title = 'Javascript中的debounce模式';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    
</div>

            <div class="end">&#10084;</div>
        </div>
        <footer id="footer">
            <small>Copyright by <a class="copyright" href="http://blog.xiaoba.me">8D IS HERE</a> | Powered by <a href="https://github.com/ibigbug/sblog">SBlog</a></small>
        </footer>
        
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-20201958-3']);
            _gaq.push(['_trackPageview']);
            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        
        <link href='http://fonts.googleapis.com/css?family=Strait&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

    </body>
</html>